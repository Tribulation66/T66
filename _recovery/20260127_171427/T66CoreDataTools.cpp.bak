#include "T66CoreDataTools.h"

#include "AssetRegistry/AssetRegistryModule.h"
#include "EditorAssetLibrary.h"
#include "Engine/DataTable.h"
#include "UObject/Package.h"

// DataCatalog + RowStructs
#include "T66/Data/Reg/T66DataCatalogDA.h"
#include "T66/Data/Schema/T66ItemRow.h"
#include "T66/Data/Schema/T66EnemyRow.h"
#include "T66/Data/Schema/T66StageEffectRow.h"
#include "T66/Data/Schema/T66CompanionRow.h"
#include "T66/Data/Schema/T66AttackPatternRow.h"
#include "T66/Data/Schema/T66MovementProfileRow.h"
#include "T66/Data/Schema/T66LuckSourceRow.h"

static UDataTable* EnsureDataTable(const FString& FolderPath, const FString& AssetName, UScriptStruct* RowStruct)
{
	if (!RowStruct)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] RowStruct is null for %s"), *AssetName);
		return nullptr;
	}

	UEditorAssetLibrary::MakeDirectory(FolderPath);

	const FString PackagePath = FolderPath + TEXT("/") + AssetName;
	const FString ObjectPath = PackagePath + TEXT(".") + AssetName;

	// Load if exists
	if (UEditorAssetLibrary::DoesAssetExist(ObjectPath))
	{
		UObject* Loaded = UEditorAssetLibrary::LoadAsset(ObjectPath);
		UDataTable* DT = Cast<UDataTable>(Loaded);
		if (!DT)
		{
			UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Exists but not a DataTable: %s"), *ObjectPath);
			return nullptr;
		}

		return DT;
	}

	// Create
	UPackage* Package = CreatePackage(*PackagePath);
	if (!Package)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Failed CreatePackage: %s"), *PackagePath);
		return nullptr;
	}

	UDataTable* NewDT = NewObject<UDataTable>(Package, UDataTable::StaticClass(), *AssetName, RF_Public | RF_Standalone);
	if (!NewDT)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Failed NewObject<UDataTable>: %s"), *AssetName);
		return nullptr;
	}

	NewDT->RowStruct = RowStruct;

	FAssetRegistryModule::AssetCreated(NewDT);
	NewDT->MarkPackageDirty();
	const bool bSaved = UEditorAssetLibrary::SaveLoadedAsset(NewDT, true);

	UE_LOG(LogTemp, Display, TEXT("[T66CoreData] Created DT: %s | RowStruct=%s | Saved=%s"),
		*ObjectPath, *GetNameSafe(RowStruct), bSaved ? TEXT("true") : TEXT("false"));

	return NewDT;
}

static UT66DataCatalogDA* EnsureDataCatalog(const FString& FolderPath, const FString& AssetName)
{
	UEditorAssetLibrary::MakeDirectory(FolderPath);

	const FString PackagePath = FolderPath + TEXT("/") + AssetName;
	const FString ObjectPath = PackagePath + TEXT(".") + AssetName;

	if (UEditorAssetLibrary::DoesAssetExist(ObjectPath))
	{
		UObject* Loaded = UEditorAssetLibrary::LoadAsset(ObjectPath);
		UT66DataCatalogDA* Catalog = Cast<UT66DataCatalogDA>(Loaded);
		if (!Catalog)
		{
			UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Exists but not UT66DataCatalogDA: %s"), *ObjectPath);
			return nullptr;
		}
		return Catalog;
	}

	UPackage* Package = CreatePackage(*PackagePath);
	if (!Package)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Failed CreatePackage for catalog: %s"), *PackagePath);
		return nullptr;
	}

	UT66DataCatalogDA* Catalog = NewObject<UT66DataCatalogDA>(Package, UT66DataCatalogDA::StaticClass(), *AssetName, RF_Public | RF_Standalone);
	if (!Catalog)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Failed NewObject<UT66DataCatalogDA>: %s"), *AssetName);
		return nullptr;
	}

	FAssetRegistryModule::AssetCreated(Catalog);
	Catalog->MarkPackageDirty();
	const bool bSaved = UEditorAssetLibrary::SaveLoadedAsset(Catalog, true);

	UE_LOG(LogTemp, Display, TEXT("[T66CoreData] Created Catalog: %s | Saved=%s"),
		*ObjectPath, bSaved ? TEXT("true") : TEXT("false"));

	return Catalog;
}

static bool ValidateDT(const TCHAR* Label, UDataTable* DT, UScriptStruct* Expected)
{
	if (!DT)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData][VALIDATE] Missing %s"), Label);
		return false;
	}

	if (DT->GetRowStruct() != Expected)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData][VALIDATE] Wrong RowStruct for %s. Expected=%s Actual=%s"),
			Label, *GetNameSafe(Expected), *GetNameSafe(DT->GetRowStruct()));
		return false;
	}

	UE_LOG(LogTemp, Display, TEXT("[T66CoreData][VALIDATE] OK %s"), Label);
	return true;
}

static bool ValidateCatalogPtr(const TCHAR* Label, const TSoftObjectPtr<UDataTable>& Ptr)
{
	if (Ptr.IsNull())
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData][VALIDATE] Catalog missing pointer: %s"), Label);
		return false;
	}

	// Load sync to confirm it resolves
	UDataTable* DT = Ptr.LoadSynchronous();
	if (!DT)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData][VALIDATE] Catalog pointer could not load: %s"), Label);
		return false;
	}

	UE_LOG(LogTemp, Display, TEXT("[T66CoreData][VALIDATE] Catalog pointer OK: %s -> %s"), Label, *DT->GetName());
	return true;
}

bool FT66CoreDataTools::CreateOrRepairAndValidateCoreData(bool /*bForceOverwrite*/)
{
	// Canonical content layout (Option A)
	const FString TablesRoot = TEXT("/Game/Tribulation66/Content/Data/Tables");
	const FString RegistriesRoot = TEXT("/Game/Tribulation66/Content/Data/Registries");

	// Core DTs
	UDataTable* DT_Items        = EnsureDataTable(TablesRoot + TEXT("/Items"),   TEXT("DT_Items"),        FT66ItemRow::StaticStruct());
	UDataTable* DT_Enemies      = EnsureDataTable(TablesRoot + TEXT("/Enemies"), TEXT("DT_Enemies"),      FT66EnemyRow::StaticStruct());
	UDataTable* DT_StageEffects = EnsureDataTable(TablesRoot + TEXT("/Stages"),  TEXT("DT_StageEffects"), FT66StageEffectRow::StaticStruct());
	UDataTable* DT_Companions   = EnsureDataTable(TablesRoot + TEXT("/Heroes"),  TEXT("DT_Companions"),   FT66CompanionRow::StaticStruct());

	// Additional DTs
	UDataTable* DT_AttackPatterns   = EnsureDataTable(TablesRoot + TEXT("/Enemies"), TEXT("DT_AttackPatterns"),   FT66AttackPatternRow::StaticStruct());
	UDataTable* DT_MovementProfiles = EnsureDataTable(TablesRoot + TEXT("/Enemies"), TEXT("DT_MovementProfiles"), FT66MovementProfileRow::StaticStruct());
	UDataTable* DT_LuckSources      = EnsureDataTable(TablesRoot + TEXT("/Sec"),     TEXT("DT_LuckSources"),      FT66LuckSourceRow::StaticStruct());

	UT66DataCatalogDA* Catalog = EnsureDataCatalog(RegistriesRoot, TEXT("DA_DataCatalog_Core"));
	if (!Catalog)
	{
		UE_LOG(LogTemp, Error, TEXT("[T66CoreData] Failed to create/load DA_DataCatalog_Core"));
		return false;
	}

	// Wire catalog (idempotent)
	Catalog->Modify();
	if (DT_Items)        Catalog->ItemsTable = DT_Items;
	if (DT_Enemies)      Catalog->EnemiesTable = DT_Enemies;
	if (DT_StageEffects) Catalog->StageEffectsTable = DT_StageEffects;
	if (DT_Companions)   Catalog->CompanionsTable = DT_Companions;

	if (DT_AttackPatterns)   Catalog->AttackPatternsTable = DT_AttackPatterns;
	if (DT_MovementProfiles) Catalog->MovementProfilesTable = DT_MovementProfiles;
	if (DT_LuckSources)      Catalog->LuckSourcesTable = DT_LuckSources;

	Catalog->MarkPackageDirty();
	const bool bSavedCatalog = UEditorAssetLibrary::SaveLoadedAsset(Catalog, true);
	UE_LOG(LogTemp, Display, TEXT("[T66CoreData] Catalog saved=%s"), bSavedCatalog ? TEXT("true") : TEXT("false"));

	// Validate DT structs
	bool bOk = true;
	bOk &= ValidateDT(TEXT("DT_Items"), DT_Items, FT66ItemRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_Enemies"), DT_Enemies, FT66EnemyRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_StageEffects"), DT_StageEffects, FT66StageEffectRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_Companions"), DT_Companions, FT66CompanionRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_AttackPatterns"), DT_AttackPatterns, FT66AttackPatternRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_MovementProfiles"), DT_MovementProfiles, FT66MovementProfileRow::StaticStruct());
	bOk &= ValidateDT(TEXT("DT_LuckSources"), DT_LuckSources, FT66LuckSourceRow::StaticStruct());

	// Validate catalog pointers resolve
	bOk &= ValidateCatalogPtr(TEXT("ItemsTable"), Catalog->ItemsTable);
	bOk &= ValidateCatalogPtr(TEXT("EnemiesTable"), Catalog->EnemiesTable);
	bOk &= ValidateCatalogPtr(TEXT("StageEffectsTable"), Catalog->StageEffectsTable);
	bOk &= ValidateCatalogPtr(TEXT("CompanionsTable"), Catalog->CompanionsTable);
	bOk &= ValidateCatalogPtr(TEXT("AttackPatternsTable"), Catalog->AttackPatternsTable);
	bOk &= ValidateCatalogPtr(TEXT("MovementProfilesTable"), Catalog->MovementProfilesTable);
	bOk &= ValidateCatalogPtr(TEXT("LuckSourcesTable"), Catalog->LuckSourcesTable);

	UE_LOG(LogTemp, Display, TEXT("[T66CoreData][VALIDATE] Overall=%s"), bOk ? TEXT("PASS") : TEXT("FAIL"));
	return bOk;
}
